import sys
import os
from PyQt5.QtWidgets import (
    QMainWindow, QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QLineEdit, QTextEdit, QPushButton, QAction, QMessageBox, QFrame, QComboBox
)
from PyQt5.QtGui import QPainter, QLinearGradient, QColor, QFont
from PyQt5.QtCore import Qt

# Determine Base Paths for Bundled vs. Normal Execution
if getattr(sys, 'frozen', False):
    BASE_PATH = sys._MEIPASS
    OUTPUT_PATH = os.path.dirname(sys.executable)
else:
    BASE_PATH = os.path.abspath(".")
    OUTPUT_PATH = BASE_PATH

# File Paths: Input files and output file
VEDIC_FILENAME = os.path.join(BASE_PATH, 'vedic_ritual_text.txt')
OTHER_FILENAME = os.path.join(BASE_PATH, 'all_other_text.txt')
OUTPUT_FILENAME = os.path.join(OUTPUT_PATH, 'search_results.txt')

# Clear the output file at startup
with open(OUTPUT_FILENAME, 'w', encoding='utf-8') as f:
    f.write("")

# Helper Functions for Gradient Colors
def hex_to_rgb(hex_color):
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

def rgb_to_hex(rgb_tuple):
    return '#%02x%02x%02x' % rgb_tuple

# Processing Functions (with positions and distance output)
def process_block(block, output_text, search_words, output_file, prev_metadata, found_flag):
    lines = block.strip().split('\n')
    text, chapter, chapter_id = prev_metadata
    sent_counter = None
    sent_subcounter = "Not Available"
    current_sentence = None
    word_positions = {word: [] for word in search_words}
    metadata_phase = True

    for line in lines:
        line = line.strip()
        # Metadata (only before content)
        if metadata_phase:
            if line.startswith('## text:'):
                text = line.replace('## text:', '').strip()
                continue
            elif line.startswith('## chapter:'):
                chapter = line.replace('## chapter:', '').strip()
                continue
            elif line.startswith('## chapter_id:'):
                chapter_id = line.replace('## chapter_id:', '').strip()
                continue
        # Content markers
        if line.startswith('# sent_counter ='):
            sent_counter = line
            metadata_phase = False
            continue
        elif line.startswith('# sent_subcounter ='):
            sent_subcounter = line.replace('# sent_subcounter =', '').strip() or "Not Available"
            metadata_phase = False
            continue
        elif line.startswith('# text ='):
            current_sentence = line
            metadata_phase = False
            continue
        # Token lines
        parts = line.split('\t')
        if len(parts) >= 3:
            # Once token parsing starts, stop metadata updates
            metadata_phase = False
            try:
                position = int(parts[0])
            except ValueError:
                continue
            lemma = parts[1] ## Based on the Declension word not on Lemma, for Lemma , change index[1] to index[2]
            if lemma in word_positions:
                word_positions[lemma].append(position)

    # If all search words found at least once
    if all(word_positions[word] for word in search_words):
        found_flag[0] = True
        # Write to output file
        with open(output_file, 'a', encoding='utf-8') as f:
            f.write(f'## text: {text}\n')
            f.write(f'## chapter: {chapter}\n')
            f.write(f'## chapter_id: {chapter_id}\n')
            f.write(f'{sent_counter}\n')
            f.write(f'# sent_subcounter = {sent_subcounter}\n')
            f.write(f'{current_sentence}\n\n')
            for word, positions in word_positions.items():
                pos_str = ", ".join(map(str, positions))
                f.write(f'The word "{word}" appears at positions: {pos_str}\n')
            f.write('\n')
            ref = search_words[0]
            ref_pos = word_positions[ref][0]
            for w in search_words[1:]:
                if word_positions[w]:
                    dist = word_positions[w][0] - ref_pos
                    if dist < 0:
                        f.write(f'"{w}" is {abs(dist)} positions before "{ref}".\n')
                    elif dist > 0:
                        f.write(f'"{w}" is {dist} positions after "{ref}".\n')
                    else:
                        f.write(f'"{w}" is at the same position as "{ref}".\n')
            f.write('\n' + '-'*40 + '\n')
        # Append to GUI
        output_text.append(f'## text: {text}')
        output_text.append(f'## chapter: {chapter}')
        output_text.append(f'## chapter_id: {chapter_id}')
        output_text.append(sent_counter)
        output_text.append(f'# sent_subcounter = {sent_subcounter}')
        output_text.append(current_sentence + '\n')
        for word, positions in word_positions.items():
            pos_str = ", ".join(map(str, positions))
            output_text.append(f'The word "{word}" appears at positions: {pos_str}')
        ref = search_words[0]
        ref_pos = word_positions[ref][0]
        for w in search_words[1:]:
            if word_positions[w]:
                dist = word_positions[w][0] - ref_pos
                if dist < 0:
                    output_text.append(f'"{w}" is {abs(dist)} positions before "{ref}".')
                elif dist > 0:
                    output_text.append(f'"{w}" is {dist} positions after "{ref}".')
                else:
                    output_text.append(f'"{w}" is at the same position as "{ref}".')
        output_text.append('\n' + '-'*40 + '\n')


def process_file(search_words, input_filename, output_filename, output_text, search_label, result_label):
    found_flag = [False]
    search_label.setText(f"Searching for: {', '.join(search_words)}")
    try:
        data = open(input_filename, 'r', encoding='utf-8').read()
    except Exception as e:
        QMessageBox.critical(None, "File Error", f"Cannot read input file:\n{e}")
        return

    blocks = data.split('# text =')
    prev = ("None", "None", "None")
    for block in blocks:
        if not block.strip():
            continue
        process_block('# text =' + block, output_text, search_words, OUTPUT_FILENAME, prev, found_flag)
        # Update prev_metadata from any metadata lines in this chunk
        for line in block.split('\n'):
            if line.startswith('## text:'):
                prev = (line.replace('## text:', '').strip(), prev[1], prev[2])
            elif line.startswith('## chapter:'):
                prev = (prev[0], line.replace('## chapter:', '').strip(), prev[2])
            elif line.startswith('## chapter_id:'):
                prev = (prev[0], prev[1], line.replace('## chapter_id:', '').strip())

    result_label.setText(
        "Words found and results saved!" if found_flag[0] else
        f"Word(s) {', '.join(search_words)} not found together."
    )

# Gradient Header
class GradientHeader(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMinimumHeight(80)
        self.title = "Sanskrit Word Search"
        self.start_color = QColor("#2196F3")
        self.end_color   = QColor("#0D47A1")
        self.text_color  = QColor("#FFFFFF")
        self.font = QFont("Segoe UI", 28, QFont.Bold)

    def paintEvent(self, event):
        p = QPainter(self)
        grad = QLinearGradient(0, 0, 0, self.height())
        grad.setColorAt(0, self.start_color)
        grad.setColorAt(1, self.end_color)
        p.fillRect(self.rect(), grad)
        p.setPen(self.text_color)
        p.setFont(self.font)
        p.drawText(self.rect(), Qt.AlignCenter, self.title)

# Main Window
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Sanskrit Word Search")
        self.resize(1024, 768)
        self.setStyleSheet("background-color: #F5F5F5;")
        self.selected_corpus_file = None

        # Menu
        mb = self.menuBar()
        fm = mb.addMenu("File")
        exit_act = QAction("Exit", self)
        exit_act.triggered.connect(self.close)
        fm.addAction(exit_act)
        hm = mb.addMenu("Help")
        about_act = QAction("About", self)
        about_act.triggered.connect(self.show_about)
        hm.addAction(about_act)

        # Layouts
        cw = QWidget()
        self.setCentralWidget(cw)
        self.vbox = QVBoxLayout(cw)
        self.vbox.setContentsMargins(15,15,15,15)
        self.vbox.setSpacing(10)

        self.vbox.addWidget(GradientHeader())

        # Status area
        sf = QFrame()
        sf.setFrameShape(QFrame.StyledPanel)
        sf.setStyleSheet("background: #E3F2FD; padding:10px;")
        sl = QVBoxLayout(sf)
        self.search_label = QLabel("")
        self.search_label.setFont(QFont("Segoe UI",14,QFont.Bold))
        self.search_label.setStyleSheet("color:#0D47A1;")
        self.result_label = QLabel("")
        self.result_label.setFont(QFont("Segoe UI",14,QFont.Bold))
        self.result_label.setStyleSheet("color:#0D47A1;")
        sl.addWidget(self.search_label)
        sl.addWidget(self.result_label)
        self.vbox.addWidget(sf)

        # Input frame
        self.input_frame = QFrame()
        self.input_frame.setFrameShape(QFrame.StyledPanel)
        self.input_frame.setStyleSheet("background:#FFF; padding:10px;")
        self.in_vbox = QVBoxLayout(self.input_frame)
        self.vbox.addWidget(self.input_frame)

        # 1) Corpus selector
        self._show_corpus_selector()

        # Output area
        self.output_area = QTextEdit()
        self.output_area.setFont(QFont("Courier",12))
        self.output_area.setReadOnly(True)
        self.output_area.setStyleSheet("background:#FFF;")
        self.vbox.addWidget(self.output_area, 1)

        self.search_again = None

    def _show_corpus_selector(self):
        w = QWidget()
        h = QHBoxLayout(w)
        lbl = QLabel("Select corpus:")
        lbl.setFont(QFont("Segoe UI",14))
        self.cbox = QComboBox()
        self.cbox.setFont(QFont("Segoe UI",14))
        self.cbox.addItems(["Vedic and Ritual Text","All Other Text"])
        btn = QPushButton("Proceed")
        btn.setFont(QFont("Segoe UI",14,QFont.Bold))
        btn.setStyleSheet("background:#3F51B5; color:#FFF;")
        btn.clicked.connect(self._on_corpus_chosen)
        h.addWidget(lbl); h.addWidget(self.cbox); h.addWidget(btn)
        self.in_vbox.addWidget(w)

    def _on_corpus_chosen(self):
        sel = self.cbox.currentText()
        self.selected_corpus_file = VEDIC_FILENAME if sel.startswith("Vedic") else OTHER_FILENAME
        self.cbox.parent().setParent(None)
        self._show_word_count_input()

    def _show_word_count_input(self):
        w = QWidget()
        h = QHBoxLayout(w)
        lbl = QLabel("How many words to search for?")
        lbl.setFont(QFont("Segoe UI",14))
        self.num_edit = QLineEdit(); self.num_edit.setFont(QFont("Segoe UI",14))
        self.num_edit.setFixedWidth(50)
        btn = QPushButton("Proceed")
        btn.setFont(QFont("Segoe UI",14,QFont.Bold))
        btn.setStyleSheet("background:#3F51B5; color:#FFF;")
        btn.clicked.connect(self._on_count_entered)
        h.addWidget(lbl); h.addWidget(self.num_edit); h.addWidget(btn)
        self.in_vbox.addWidget(w)

    def _on_count_entered(self):
        try:
            n = int(self.num_edit.text().strip())
            if n <= 0: raise ValueError
        except ValueError:
            QMessageBox.critical(self,"Invalid","Enter a positive integer.")
            return
        self.num_edit.parent().setParent(None)
        self._show_word_entries(n)

    def _show_word_entries(self, n):
        self.entries = []
        for i in range(n):
            w = QWidget(); h = QHBoxLayout(w)
            lbl = QLabel(f"Enter word {i+1} to search for:"); lbl.setFont(QFont("Segoe UI",14))
            edt = QLineEdit(); edt.setFont(QFont("Segoe UI",14)); edt.setFixedWidth(400)
            h.addWidget(lbl); h.addWidget(edt)
            self.entries.append(edt)
            self.in_vbox.addWidget(w)
        btn = QPushButton("Start Search")
        btn.setFont(QFont("Segoe UI",14,QFont.Bold))
        btn.setStyleSheet("background:#3F51B5; color:#FFF;")
        btn.clicked.connect(self._start_search)
        self.in_vbox.addWidget(btn)

    def _start_search(self):
        words = [e.text().strip() for e in self.entries if e.text().strip()]
        if not words:
            QMessageBox.critical(self,"Error","Enter at least one word.")
            return
        self.search_label.setText(f"Searching for: {', '.join(words)}")
        self.output_area.clear()
        process_file(words, self.selected_corpus_file, OUTPUT_FILENAME,
                     self.output_area, self.search_label, self.result_label)
        self._show_search_again()

    def _show_search_again(self):
        if self.search_again:
            self.search_again.setParent(None)
        w = QWidget(); h = QHBoxLayout(w)
        y = QPushButton("Yes (Search Again)"); n = QPushButton("No (Exit)")
        for btn, col in [(y,"#388E3C"),(n,"#D32F2F")]:
            btn.setFont(QFont("Segoe UI",14,QFont.Bold))
            btn.setStyleSheet(f"background:{col}; color:#FFF;")
        y.clicked.connect(self._reset)
        n.clicked.connect(self.close)
        h.addWidget(y); h.addWidget(n)
        self.vbox.addWidget(w)
        self.search_again = w

    def _reset(self):
        # clear inputs
        for i in reversed(range(self.in_vbox.count())):
            w = self.in_vbox.itemAt(i).widget()
            if w: w.setParent(None)
        if self.search_again: self.search_again.setParent(None)
        self.search_label.clear(); self.result_label.clear()
        self.output_area.clear()
        self._show_corpus_selector()

    def show_about(self):
        QMessageBox.information(self, "About",
            "DCS-Sanskrit Word Search\nVersion 1.0\nDeveloped by Irfan Ali"
        )

def main():
    app = QApplication(sys.argv)
    mw = MainWindow()
    mw.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
